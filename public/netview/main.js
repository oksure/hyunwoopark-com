// Generated by CoffeeScript 2.4.1
// future features

// force label placement & highlights
// https://bl.ocks.org/mapio/53fed7d84cd1812d6a6639ed7aa83868
// http://bl.ocks.org/MoritzStefaner/1377729

// curved edges
// https://bl.ocks.org/almsuarez/baa897c189ed64ba2bb32cde2876533b

// force tooltip & highlights
// https://bl.ocks.org/almsuarez/4333a12d2531d6c1f6f22b74f2c57102

// align tooltip position when zoomed (mismatch because of transform, translate, scale)
// https://bl.ocks.org/anonymous/3e3e5333ff24a2c9972bc9320dc6f712/f4dcd09a07b5eafdc78efa0cf45948021e003739

// global variables
// [svg, svgNodes, svgLinks, svgTexts, width, height, color, nodes, links, force, node, link, text, zoom, drag, graph] = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]
var centerToXY, color, drag, dragended, dragged, dragging, dragstarted, exitHighlight, g, gc20, getTransform, graph, height, hideDetails, init, initUI, isEdgeOf, isEdgeSelected, isLinkOn, isNeighbor, isNodeSelected, isPartOf, isSameEdge, isSameNode, isTextOn, isTooltipOn, link, links, nborsdic, node, nodeColor, nodes, resetCanvas, resetSelected, resetSize, selected, setHighlightByNode, setHighlightByStr, showDetails, showNodeDetailsInPanel, openRightPanel, buildGroupFilterUI, applyGroupFilter, currentGroupFilter, simulation, svg, svgLinks, svgNodes, svgTexts, text, tick, url, width, zoom, rawLinks, filteredNodes, filteredLinks, selectedNodeId, updateSelectedNodeClass, linkKey, clearSelection, clearDetailsPanel, gravityStrength;

svg = null;

g = null;

svgNodes = null;

svgLinks = null;

svgTexts = null;

width = null;

height = null;

color = null;

nodes = null;

links = null;

simulation = null;

node = null;

link = null;

text = null;

zoom = null;

drag = null;

graph = null;

selected = null;

dragging = null;

nborsdic = null;

gc20 = '#3366cc #dc3912 #ff9900 #109618 #990099 #0099c6 #dd4477 #66aa00 #b82e2e #316395 #994499 #22aa99 #aaaa11 #6633cc #e67300 #8b0707 #651067 #329262 #5574a6 #3b3eac'.split(' ');

url = location.search.substr(1, 24) === "https://www.dropbox.com/" ? location.search.substr(1).replace('www.dropbox.com', 'dl.dropboxusercontent.com') : "https://dl.dropboxusercontent.com/s/vn98nq1g5fn6dkk/miserable.json?dl=0";

// active group filter set (values are group keys converted to string for uniformity)
currentGroupFilter = null;
rawLinks = null;
filteredNodes = null;
filteredLinks = null;
selectedNodeId = null;
linkKey = function(d){
  var s = (d && d.source && d.source.id != null) ? d.source.id : (d && d.source != null ? d.source : d.s);
  var t = (d && d.target && d.target.id != null) ? d.target.id : (d && d.target != null ? d.target : d.t);
  return String(s) + '-' + String(t);
};

// initialize ui
init = function() {
  $('#last-updated').text(document.lastModified);
  // initTooltips()
  initUI();
  color = d3.scaleOrdinal().domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]).range(gc20);
  drag = d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
  zoom = d3.zoom().scaleExtent([.1, 10]).on('zoom', function(event) {
    g.attr('transform', event.transform);
  });
  // render graph
  resetCanvas();
  $('#spinner').show();
  d3.json(url).then(function(data) {
    graph = data;
    // console.log graph
    nborsdic = {};
    $.map(graph.nodes, function(v) {
      nborsdic[v.id] = [];
    });
    $.map(graph.links, function(e) {
      if (!nborsdic.hasOwnProperty(e.source)) {
        nborsdic[e.source] = [];
      }
      if (!nborsdic.hasOwnProperty(e.target)) {
        nborsdic[e.target] = [];
      }
      nborsdic[e.source].push(e.target);
      nborsdic[e.target].push(e.source);
    });
    // keep a stable, id-based copy of links for filtering
    rawLinks = graph.links.map(function(e){
      var sid = (e && e.source && e.source.id != null) ? e.source.id : e.source;
      var tid = (e && e.target && e.target.id != null) ? e.target.id : e.target;
      var out = { s: sid, t: tid };
      if (e.hasOwnProperty('value')) out.value = e.value;
      return out;
    });
    // initialize simulation
    simulation = d3.forceSimulation(graph.nodes)
      .force('charge', d3.forceManyBody().strength(-100))
      .force('collide', d3.forceCollide())
      .force('link', d3.forceLink(graph.links).id(function(d) { return d.id; }))
      .force('center', d3.forceCenter(width / 2, height / 2))
      // Add gentle gravity towards center so components stay nearby
      .force('x', d3.forceX(width / 2).strength(gravityStrength))
      .force('y', d3.forceY(height / 2).strength(gravityStrength))
      .on('tick', tick);
    // build filters now that we have data
    buildGroupFilterUI(graph.nodes);
    // apply initial filter (all on): binds selections and restarts sim
    applyGroupFilter();
    svg.call(zoom.transform, d3.zoomIdentity);
    $('#spinner').hide();
  });
};

// force computation for every tick
tick = function() {
  text.attr('transform', function(d) {
    return 'translate(' + [d.x, d.y] + ')';
  });
  node.attr('cx', function(d) {
    return d.x;
  }).attr('cy', function(d) {
    return d.y;
  });
  link.attr('x1', function(d) {
    return d.source.x;
  }).attr('y1', function(d) {
    return d.source.y;
  }).attr('x2', function(d) {
    return d.target.x;
  }).attr('y2', function(d) {
    return d.target.y;
  });
};

// node-dragging-related functions
dragstarted = function(event, d) {
  if (!event.active) {
    simulation.alphaTarget(0.3).restart();
  }
  d.fx = d.x;
  d.fy = d.y;
  dragging = true;
};

dragged = function(event, d) {
  d.fx = event.x;
  d.fy = event.y;
};

dragended = function(event, d) {
  if (!event.active) {
    simulation.alphaTarget(0.0001);
  }
  d.fx = null;
  d.fy = null;
  dragging = false;
  exitHighlight();
};

// if not $('#control-force').hasClass 'active' then force.stop()
centerToXY = function(x, y, k, delay) {
  var transform, translate;
  translate = [width / 2 - (k * x), height / 2 - (k * y)];
  transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(k);
  svg.transition().duration(delay).call(zoom.transform, transform);
};

getTransform = function() {
  return $('svg > g').attr('transform').match(/([\d\.]+)/g).map(parseFloat);
};

nodeColor = function(d) {
  if (d.hasOwnProperty('color')) {
    return d.color;
  }
  if (d.hasOwnProperty('group')) {
    return color(d.group);
  } else {
    return color(1);
  }
};

showDetails = function(d) {
  var tt;
  tt = $('#tooltip');
  tt.html(JSON.stringify(d, ['id', 'label', 'group', 'color', 'size', 'source', 'target', 'value'], 2));
  // tt.html JSON.stringify(d, null, 2)
  if (d.hasOwnProperty('x')) {
    tt.css('left', 10 + d.x);
    tt.css('top', 10 + d.y);
  } else {
    tt.css('left', 10 + (d.source.x + d.target.x) / 2);
    tt.css('top', 10 + (d.source.y + d.target.y) / 2);
  }
  if (isTooltipOn()) {
    tt.removeClass('d-none');
  }
};

hideDetails = function(d) {
  $('#tooltip').addClass('d-none');
};

updateSelectedNodeClass = function() {
  if (!node) return;
  node.classed('selected', function(p){ return selectedNodeId != null && p.id === selectedNodeId; });
  // bring selected to front for visibility
  try {
    node.filter(function(p){ return selectedNodeId != null && p.id === selectedNodeId; }).each(function(){ this.parentNode.appendChild(this); });
  } catch(e) {}
};

// Right panel details rendering
showNodeDetailsInPanel = function(d) {
  var container = document.getElementById('details-container');
  if (!container) return;
  var safeEntries = [];
  // Show core fields prominently, then the rest sorted
  var coreOrder = ['id','label','group','size','color'];
  var seen = {};
  coreOrder.forEach(function(k){ if(d && Object.prototype.hasOwnProperty.call(d,k)){ seen[k]=true; safeEntries.push([k,d[k]]); }});
  Object.keys(d || {}).sort().forEach(function(k){ if(!seen[k]){ safeEntries.push([k,d[k]]); }});
  var html = '<div class="mb-2">' +
    '<div class="fw-bold">' + (d.label || d.id) + '</div>' +
    (d.group != null ? '<div class="text-muted">Group: ' + d.group + '</div>' : '') +
    '</div>';
  html += '<dl class="row mb-0">';
  safeEntries.forEach(function(pair){
    html += '<dt class="col-4">' + String(pair[0]) + '</dt>' +
            '<dd class="col-8" style="word-break: break-word;">' + String(pair[1]) + '</dd>';
  });
  html += '</dl>';
  container.innerHTML = html;
};

openRightPanel = function() {
  var right = document.getElementById('rightDrawer');
  if (!right) return;
  if (!right.classList.contains('show')) {
    right.classList.add('show');
  }
  // ensure handle slides out
  if (typeof window.__initDualOffcanvas === 'function') {
    // handles are already bound; just reposition
    setTimeout(function(){
      try { positionExternalHandles(); } catch(e){}
    }, 0);
  }
};

// Build left-panel group filter checkboxes from node data
buildGroupFilterUI = function(nodesArr) {
  var container = document.getElementById('group-filter');
  if (!container) return;
  var groups = {};
  (nodesArr || []).forEach(function(n){
    var g = (n.hasOwnProperty('group') ? n.group : 1);
    var key = String(g);
    groups[key] = (groups[key] || 0) + 1;
  });
  var keys = Object.keys(groups).sort(function(a,b){
    var na = +a, nb = +b;
    if(!isNaN(na) && !isNaN(nb)) return na - nb;
    return a.localeCompare(b);
  });
  // initial filter = all groups checked
  currentGroupFilter = new Set(keys);
  // render checkboxes
  var html = '';
  keys.forEach(function(k){
    var id = 'chk-group-' + k.replace(/[^a-zA-Z0-9_-]/g,'_');
    html += '\n<div class="form-check">\
      <input class="form-check-input" type="checkbox" value="' + k + '" id="' + id + '" checked>\
      <label class="form-check-label" for="' + id + '">Group ' + k + ' <span class="text-muted">(' + groups[k] + ')</span></label>\
    </div>';
  });
  container.innerHTML = html || '<div class="text-muted">No groups</div>';
  // attach listeners
  container.querySelectorAll('input[type="checkbox"]').forEach(function(cb){
    cb.addEventListener('change', function(){
      var val = this.value;
      if (this.checked) currentGroupFilter.add(val); else currentGroupFilter.delete(val);
      applyGroupFilter();
    });
  });
  var btnAll = document.getElementById('group-filter-all');
  var btnNone = document.getElementById('group-filter-none');
  if (btnAll) btnAll.addEventListener('click', function(){
    currentGroupFilter = new Set(keys);
    container.querySelectorAll('input[type="checkbox"]').forEach(function(cb){ cb.checked = true; });
    applyGroupFilter();
  });
  if (btnNone) btnNone.addEventListener('click', function(){
    currentGroupFilter = new Set();
    container.querySelectorAll('input[type="checkbox"]').forEach(function(cb){ cb.checked = false; });
    applyGroupFilter();
  });
};

// Apply filtering by rebinding data and restarting the simulation
applyGroupFilter = function() {
  if (!currentGroupFilter) return;
  // compute allowed nodes
  var isAllowedNode = function(n){
    var gval = n.hasOwnProperty('group') ? n.group : 1;
    return currentGroupFilter.has(String(gval));
  };
  var allowedIds = new Set();
  filteredNodes = graph.nodes.filter(function(n){
    var allowed = isAllowedNode(n);
    if (allowed) allowedIds.add(n.id);
    return allowed;
  });
  // if selected node not allowed anymore, clear selection and details
  if (selectedNodeId != null && !allowedIds.has(selectedNodeId)) {
    selectedNodeId = null;
    selected = null;
    clearDetailsPanel();
  }
  // filter links using raw link ids; create objects with both id references and force fields
  filteredLinks = rawLinks.filter(function(l){ return allowedIds.has(l.s) && allowedIds.has(l.t); })
    .map(function(l){ return { s: l.s, t: l.t, value: l.value, source: l.s, target: l.t }; });

  // rebind selections
  link = svgLinks.selectAll('.link')
    .data(filteredLinks, linkKey)
    .join('line')
    .attr('class', 'link')
    .style('stroke-width', function(d) { return d.hasOwnProperty('value') ? d.value : 1; })
    .on('mouseover', function(event, d) { showDetails(d); })
    .on('mouseout', function(event, d) { hideDetails(); });

  node = svgNodes.selectAll('.node')
    .data(filteredNodes, function(d){ return d.id; })
    .join('circle')
    .attr('class', 'node')
    .attr('r', function(d){ return d.hasOwnProperty('size') ? d.size : 6; })
    .style('fill', function(d){ return nodeColor(d); })
    .style('stroke', function(d){ return nodeColor(d); })
    .call(drag)
    .on('mouseover', function(event, d){ setHighlightByNode(d, true); showDetails(d); })
    .on('mouseout', function(event, d){ exitHighlight(); hideDetails(); })
    .on('click', function(event, d){
      event.stopPropagation();
      if (!event.defaultPrevented){
        selected = d;
        selectedNodeId = d.id;
        updateSelectedNodeClass();
        showNodeDetailsInPanel(d);
        openRightPanel();
        return centerToXY(d.x, d.y, getTransform()[2], 750);
      }
    });

  text = svgTexts.selectAll('.text')
    .data(filteredNodes, function(d){ return d.id; })
    .join('text')
    .attr('class', 'text')
    .attr('dx', function(d){ return d.hasOwnProperty('size') ? d.size + 4 : 10; })
    .attr('dy', '.35em')
    .attr('font-size', '9pt')
    .text(function(d){ return d.hasOwnProperty('label') ? d.label : d.id; })
    .call(drag)
    .on('mouseover', function(event, d){ setHighlightByNode(d, true); showDetails(d); })
    .on('mouseout', function(event, d){ exitHighlight(); hideDetails(); })
    .on('click', function(event, d){
      event.stopPropagation();
      if (!event.defaultPrevented){
        selected = d;
        selectedNodeId = d.id;
        updateSelectedNodeClass();
        showNodeDetailsInPanel(d);
        openRightPanel();
        return centerToXY(d.x, d.y, getTransform()[2], 750);
      }
    });

  updateSelectedNodeClass();

  // restart the simulation with filtered data
  simulation.nodes(filteredNodes);
  simulation.force('link').links(filteredLinks);
  simulation.alpha(1).restart();
};

// init all tooltips
// initTooltips = ->
//   $( -> $('[data-toggle="tooltip"]').tooltip(); return); return
initUI = function() {
  $('.nav-toggle').click(function(event) {
    event.preventDefault();
    if (this.text.split(': ')[1] === 'On') {
      g.selectAll('.' + this.id.split('-')[1]).classed('d-none', true);
      // $('.main-canvas .'+this.id.split('-')[1]).hide()
      this.text = this.text.split(': ')[0] + ': Off';
    } else {
      g.selectAll('.' + this.id.split('-')[1]).classed('d-none', false);
      // $('.main-canvas .'+this.id.split('-')[1]).show()
      this.text = this.text.split(': ')[0] + ': On';
    }
    $(this).blur();
  });
  $('#quick-search').on('keyup search click', function(event) {
    var qsVal;
    if (selected) {
      resetSelected();
    }
    qsVal = $('#quick-search').val();
    if (qsVal.length > 0) {
      setHighlightByStr(qsVal);
    } else {
      exitHighlight();
    }
  });
  // Gravity strength slider
  (function(){
    var $slider = $('#gravity-strength');
    var $label = $('#gravity-strength-value');
    function applyStrength(val){
      var s = Math.max(0, Math.min(0.1, +val || 0));
      gravityStrength = s;
      if ($label && $label.length) { $label.text(s.toFixed(3)); }
      if (simulation) {
        var fx = simulation.force('x');
        var fy = simulation.force('y');
        if (fx && typeof fx.strength === 'function') fx.strength(s);
        if (fy && typeof fy.strength === 'function') fy.strength(s);
        simulation.alphaTarget(0.2).restart();
        setTimeout(function(){ try { simulation.alphaTarget(0); } catch(e){} }, 400);
      }
    }
    if ($slider && $slider.length) {
      // initialize display and state
      applyStrength($slider.val());
      $slider.on('input change', function(){ applyStrength(this.value); });
    }
  })();
  $('.modal').on('shown.bs.modal', function(e) {
    $('.nav-link').one('focus', function(e) {
      return $(this).blur();
    });
  });
};

isTextOn = function() {
  return $('#toggle-text').text().split(': ')[1] === 'On';
};

isLinkOn = function() {
  return $('#toggle-link').text().split(': ')[1] === 'On';
};

isTooltipOn = function() {
  return $('#toggle-tooltip').text().split(': ')[1] === 'On';
};

// hover & quick search highlight functions
isNeighbor = function(p, d) {
  return p.id === d.id || nborsdic[d.id].indexOf(p.id) >= 0; // check if p is one of d's neighbors
};

isPartOf = function(p, s) {
  var flagId, flagLabel;
  flagId = p.id.toString().toLowerCase().indexOf(s.toLowerCase()) >= 0;
  flagLabel = p.hasOwnProperty('label') ? p.label.toString().toLowerCase().indexOf(s.toLowerCase()) >= 0 : false;
  return flagId || flagLabel;
};

// check if s [string] is part of p [node] id or label
isSameNode = function(p, d) {
  return p.id === d.id; // check if p [node] is same to d [node]
};

isSameEdge = function(p, d) {
  return (p.source.id === d.source.id && p.target.id === d.target) || (p.source.id === d.target.id && p.target.id === d.source.id); // check if p [edge] is same to d [edge]
};

isEdgeOf = function(p, d) {
  return p.source.id === d.id || p.target.id === d.id; // is p [edge] an edge of d [node]
};

isNodeSelected = function() {
  return selected && !selected.hasOwnProperty('source');
};

isEdgeSelected = function() {
  return selected && selected.hasOwnProperty('source');
};

setHighlightByNode = function(d, hover) {
  if (link !== null) {
    if (!dragging) {
      link.classed('dim', function(p) {
        return !isEdgeOf(p, d);
      }).classed('d-none', function(p) {
        return !isLinkOn() && !isEdgeOf(p, d);
      });
      // .classed 'selected', (p) -> (not hover) and isEdgeSelected() and isSameEdge p,selected
      node.classed('dim', function(p) {
        return !isNeighbor(p, d);
      });
      // .classed 'selected', (p) -> (not hover) and isNodeSelected() and isSameNode p,selected
      text.classed('dim', function(p) {
        return !isNeighbor(p, d);
      }).classed('d-none', function(p) {
        return !isTextOn() && !isNeighbor(p, d);
      });
    }
  }
};

// setHighlightByEdge = (d, hover) ->
//   if link!=null
//     if not dragging
//       link
//         .classed 'dim', (p) -> not isSameEdge p,d
//         .classed 'd-none', (p) -> not isLinkOn() and not isSameEdge p,d
//         .classed 'selected', (p) -> (not hover) and isEdgeSelected() and isSameEdge p,selected
//       node
//         .classed 'dim', (p) -> not isEdgeOf d,p
//         .classed 'selected', (p) -> (not hover) and isNodeSelected() and isSameNode p,selected
//       text
//         .classed 'dim', (p) -> not isEdgeOf d,p
//         .classed 'd-none', (p) -> not isTextOn() and not isEdgeOf d,p
//   return
setHighlightByStr = function(s) {
  // console.log s.toLowerCase()
  if (link !== null) {
    link.classed('dim', true).classed('d-none', function(p) {
      return !isLinkOn();
    });
    // .classed 'selected', (p) -> isEdgeSelected() and isSameEdge p,selected
    node.classed('dim', function(p) {
      return !isPartOf(p, s);
    });
    // .classed 'selected', (p) -> isNodeSelected() and isSameNode p,selected
    text.classed('dim', function(p) {
      return !isPartOf(p, s);
    }).classed('d-none', function(p) {
      return !isTextOn() && !isPartOf(p, s);
    });
  }
};

exitHighlight = function() {
  if (link !== null) {
    if (!dragging) {
      if (selected) {
        if (selected.hasOwnProperty('source')) {
          setHighlightByEdge(selected, false);
        } else {
          setHighlightByNode(selected, false);
        }
      } else {
        if ($('#quick-search').val().length > 0) {
          setHighlightByStr($('#quick-search').val());
        } else {
          link.classed('dim', false).classed('d-none', function(p) {
            return !isLinkOn();
          }).classed('selected', false);
          node.classed('dim', false).classed('selected', false);
          text.classed('dim', false).classed('d-none', function(p) {
            return !isTextOn();
          });
        }
      }
    }
  }
};

resetSelected = function() {
  if (link !== null) {
    selected = null;
    exitHighlight();
  }
};

clearDetailsPanel = function(){
  var container = document.getElementById('details-container');
  if (!container) return;
  container.innerHTML = '<p class="text-muted mb-0">Click a node to see details here.</p>';
};

clearSelection = function(){
  selected = null;
  selectedNodeId = null;
  updateSelectedNodeClass();
  clearDetailsPanel();
  exitHighlight();
  hideDetails();
};

resetSize = function() {
  width = $('#canvas').width();
  height = $('#canvas').height();
};

// if zoom!=null then zoom.center [width / 2, height / 2]
// if svg!=null then svg.attr "viewBox", "0 0 " + width + " " + height
resetCanvas = function() {
  resetSize();
  // zoom.center [width / 2, height / 2]
  // zoom.translate [0, 0]
  $('#canvas').empty();
  // .attr "viewBox", "0 0 " + width + " " + height
  // .attr 'cursor', 'move'
  svg = d3.select('#canvas').append('svg').attr('class', 'main-canvas').call(zoom);
  // Close both sidebars when clicking on the empty SVG background (not during drag/zoom)
  svg.on('click', function(event){
    if (event && event.defaultPrevented) return; // ignore if drag/zoom consumed the event
    if (event && event.target !== svg.node()) return; // only background, not nodes/text
    var leftCanvas = document.getElementById('leftDrawer');
    var rightCanvas = document.getElementById('rightDrawer');
    var changed = false;
    // Additionally, reset the quick search textbox when background is clicked
    var $qs = $('#quick-search');
    if ($qs && $qs.length) {
      $qs.val('');
      // trigger built-in search handler to clear highlights
      $qs.trigger('search');
    }
  if(leftCanvas && leftCanvas.classList.contains('show')){ leftCanvas.classList.remove('show'); changed = true; }
  if(rightCanvas && rightCanvas.classList.contains('show')){ rightCanvas.classList.remove('show'); changed = true; }
    if(changed) positionExternalHandles();
  // also clear any selection and details
  clearSelection();
  });
  // .on 'click', (d) ->
  //   if not d3.event.defaultPrevented then resetSelected()
  //   return
  g = svg.append('g');
  // svg.attr 'transform', d3.zoomIdentity
  svgLinks = g.append('g');
  svgNodes = g.append('g');
  svgTexts = g.append('g');
};



function setNavbarHeightVar(){
  var nav = document.querySelector('.navbar.fixed-top');
  var h = nav ? nav.offsetHeight : 56;
  document.documentElement.style.setProperty('--app-navbar-height', h + 'px');
}
function positionExternalHandles(){
  var leftCanvas = document.getElementById('leftDrawer');
  var rightCanvas = document.getElementById('rightDrawer');
  var leftHandle = document.querySelector('.drawer-handle-left');
  var rightHandle = document.querySelector('.drawer-handle-right');
  var edgeOffset = '0';
  if(leftCanvas && leftHandle){
    var leftOpen = leftCanvas.classList.contains('show');
    if(leftOpen){
      leftHandle.style.left = (leftCanvas.offsetWidth) + 'px';
      leftHandle.textContent = '◀';
    } else {
      leftHandle.style.left = edgeOffset;
      leftHandle.textContent = '▶';
    }
  }
  if(rightCanvas && rightHandle){
    var rightOpen = rightCanvas.classList.contains('show');
    if(rightOpen){
      rightHandle.style.right = (rightCanvas.offsetWidth) + 'px';
      rightHandle.textContent = '▶';
    } else {
      rightHandle.style.right = edgeOffset;
      rightHandle.textContent = '◀';
    }
  }
}
(function(){
  var openingCanvasId = null; // track an offcanvas being opened to suppress auto-hiding others

  function animateHandle(side, isOpen){
    var canvas = document.getElementById(side === 'left' ? 'leftDrawer' : 'rightDrawer');
    var handle = document.querySelector(side === 'left' ? '.drawer-handle-left' : '.drawer-handle-right');
    if(!canvas || !handle) return;
    var prop = side === 'left' ? 'left' : 'right';
    var target = isOpen ? (canvas.offsetWidth + 'px') : '0';
    // schedule on next frame to sync with Bootstrap applying classes for transition
    requestAnimationFrame(function(){
      handle.style[prop] = target;
    });
  }
  function finalizeHandle(side, isOpen){
    var canvas = document.getElementById(side === 'left' ? 'leftDrawer' : 'rightDrawer');
    var handle = document.querySelector(side === 'left' ? '.drawer-handle-left' : '.drawer-handle-right');
    if(!canvas || !handle) return;
    var prop = side === 'left' ? 'left' : 'right';
    var target = isOpen ? (canvas.offsetWidth + 'px') : '0';
    handle.style[prop] = target;
    // update arrow icons when final state is reached
    if(side === 'left'){
      handle.textContent = isOpen ? '◀' : '▶';
    } else {
      handle.textContent = isOpen ? '▶' : '◀';
    }
  }
  function bindOffcanvasEvents(){
    var leftCanvas = document.getElementById('leftDrawer');
    var rightCanvas = document.getElementById('rightDrawer');

    if(leftCanvas){
      leftCanvas.addEventListener('show.bs.offcanvas', function(){ openingCanvasId = 'leftDrawer'; animateHandle('left', true); });
      leftCanvas.addEventListener('shown.bs.offcanvas', function(){ openingCanvasId = null; finalizeHandle('left', true); });
      leftCanvas.addEventListener('hide.bs.offcanvas', function(e){
        // Prevent Bootstrap from auto-hiding when the other offcanvas opens
        if(openingCanvasId && openingCanvasId !== 'leftDrawer') { e.preventDefault(); return; }
        animateHandle('left', false);
      });
      leftCanvas.addEventListener('hidden.bs.offcanvas', function(){ finalizeHandle('left', false); });
      leftCanvas.addEventListener('transitionend', function(){ positionExternalHandles(); }, true);
    }
    if(rightCanvas){
      rightCanvas.addEventListener('show.bs.offcanvas', function(){ openingCanvasId = 'rightDrawer'; animateHandle('right', true); });
      rightCanvas.addEventListener('shown.bs.offcanvas', function(){ openingCanvasId = null; finalizeHandle('right', true); });
      rightCanvas.addEventListener('hide.bs.offcanvas', function(e){
        if(openingCanvasId && openingCanvasId !== 'rightDrawer') { e.preventDefault(); return; }
        animateHandle('right', false);
      });
      rightCanvas.addEventListener('hidden.bs.offcanvas', function(){ finalizeHandle('right', false); });
      rightCanvas.addEventListener('transitionend', function(){ positionExternalHandles(); }, true);
    }
  }
  // expose to outer scope replacing previous binder
  window.__bindOffcanvasEvents = bindOffcanvasEvents;
})();

window.addEventListener('load', function(){
  setNavbarHeightVar();
  // replace old binder with new synced behavior
  if(typeof window.__bindOffcanvasEvents === 'function') window.__bindOffcanvasEvents();
  positionExternalHandles();
});
window.addEventListener('resize', function(){
  setNavbarHeightVar();
  positionExternalHandles();
});
(function(){
  function drawerEl(side){ return document.getElementById(side === 'left' ? 'leftDrawer' : 'rightDrawer'); }
  function handleEl(side){ return document.querySelector(side === 'left' ? '.drawer-handle-left' : '.drawer-handle-right'); }
  function isOpen(side){ var el = drawerEl(side); return !!el && el.classList.contains('show'); }
  function setIcon(side, open){ var h = handleEl(side); if(!h) return; h.textContent = side === 'left' ? (open ? '◀' : '▶') : (open ? '▶' : '◀'); }
  function moveHandle(side, open){
    var el = drawerEl(side), h = handleEl(side); if(!el || !h) return;
    var prop = side === 'left' ? 'left' : 'right';
    var target = open ? (el.offsetWidth + 'px') : '0';
    requestAnimationFrame(function(){ h.style[prop] = target; });
  }
  function openDrawer(side){
    var el = drawerEl(side); if(!el) return;
    // ensure visibility during slide-in
    el.style.display = 'block';
    // force reflow to enable transition
    void el.offsetWidth;
    if(!el.classList.contains('show')){ el.classList.add('show'); }
    moveHandle(side, true); setIcon(side, true);
  }
  function closeDrawer(side){
    var el = drawerEl(side); if(!el) return;
    if(el.classList.contains('show')){
      // keep visible during slide-out
      el.style.display = 'block';
      el.classList.remove('show');
      var onEnd = function(ev){
        if(ev && ev.target !== el) return;
        el.style.display = 'none';
        el.removeEventListener('transitionend', onEnd, true);
      };
      el.addEventListener('transitionend', onEnd, true);
    }
    moveHandle(side, false); setIcon(side, false);
  }
  function toggleDrawer(side){ isOpen(side) ? closeDrawer(side) : openDrawer(side); }
  function interceptClick(el, handler){ if(!el) return; el.addEventListener('click', function(e){ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); handler(e); }, true); }
  function stripBootstrapDataAPI(){
    var lh = handleEl('left');
    var rh = handleEl('right');
    [lh, rh].forEach(function(h){
      if(!h) return;
      h.removeAttribute('data-bs-toggle');
      h.removeAttribute('data-bs-target');
      h.removeAttribute('aria-controls');
    });
    var leftClose = document.querySelector('#leftDrawer .btn-close, #leftDrawer [data-bs-dismiss="offcanvas"]');
    var rightClose = document.querySelector('#rightDrawer .btn-close, #rightDrawer [data-bs-dismiss="offcanvas"]');
    [leftClose, rightClose].forEach(function(btn){ if(btn){ btn.removeAttribute('data-bs-dismiss'); }});
  }
  function bindDualOffcanvas(){
    stripBootstrapDataAPI();
    // Intercept external handles (prevent Bootstrap Data API) and toggle independently
    interceptClick(handleEl('left'), function(){ toggleDrawer('left'); });
    interceptClick(handleEl('right'), function(){ toggleDrawer('right'); });
    // Intercept internal close buttons
    var leftClose = document.querySelector('#leftDrawer .btn-close');
    var rightClose = document.querySelector('#rightDrawer .btn-close');
    interceptClick(leftClose, function(){ closeDrawer('left'); });
    interceptClick(rightClose, function(){ closeDrawer('right'); });
    // Sync on transition end (in case of resize mid-animation)
    var leftCanvas = drawerEl('left');
    var rightCanvas = drawerEl('right');
    if(leftCanvas){ leftCanvas.addEventListener('transitionend', function(){ moveHandle('left', isOpen('left')); }, true); }
    if(rightCanvas){ rightCanvas.addEventListener('transitionend', function(){ moveHandle('right', isOpen('right')); }, true); }
    // Initial state
    moveHandle('left', false); setIcon('left', false);
    moveHandle('right', false); setIcon('right', false);
  }
  window.__initDualOffcanvas = bindDualOffcanvas;
  // expose helpers for external calls
  window.__offcanvasOpenDrawer = openDrawer;
  window.__offcanvasCloseDrawer = closeDrawer;
  window.__offcanvasToggleDrawer = toggleDrawer;
})();

window.addEventListener('load', function(){
  setNavbarHeightVar();
  // initialize custom dual offcanvas behavior (independent open/close)
  if(typeof window.__initDualOffcanvas === 'function') window.__initDualOffcanvas();
  positionExternalHandles();
});
window.addEventListener('resize', function(){
  setNavbarHeightVar();
  positionExternalHandles();
});



// initialization when document gets ready
$(function() {
  init();
});
